---
layout: page
title: "The Application and its RequestSink"
category: http
date: 2016-06-19 21:22:35
order: 5
---

An `Application<T>` manages the starting and stopping of an Aqueduct application. A simple Aqueduct startup script contains a `main` function that creates and `start`s an instance of `Application<T>`:

```dart
import 'package:aqueduct/aqueduct.dart';
import 'package:myapp/myapp.dart';

main() {
  var app = new Application<MyRequestSink>();
  app.start();
}
```

The type argument of `Application<T>` must be a subclass of `RequestSink`. This subclass defines the application-specific behavior of the application. Every application has one `RequestSink` type, in which methods are overridden to set up routes and other resources, like database connections.

Therefore, an Aqueduct application has two primary components: an application library that contains a `RequestSink` subclass, and a Dart script with a `main` function that creates and starts an `Application<T>`.

The source code for the `RequestSink` subclass - and all of the classes it uses - lives in a project's `lib` directory. The start script lives in the project's `bin` directory. To start an Aqueduct application, you run the Dart script in the `bin` directory.

## The Application Object

An `Application<T>` is the top-level object in an Aqueduct application; it listens for HTTP requests and sends them to `RequestSink` instances. The `Application<T>` itself is just a generic container for `RequestSink`s; it doesn't do much other than kick everything off. (`RequestSink`s are described in more detail later in this guide.)

The application's `start` method will initialize at least one instance of the application's `RequestSink`. If something goes wrong during this initialization process, the application will throw an exception and halt starting the server. For example, setting up an invalid route in a `RequestSink` subclass would trigger this type of startup exception.

An `Application<T>` has a number of options that determine how it will listen for HTTP requests, such as which port it is listening on or the SSL certificate it will use. These values are available in the application's `configuration` property, an instance of `ApplicationConfiguration`.

An application will likely have other kinds of configurable options that are specific to the application, like connection information for a database. For this purpose, `ApplicationConfiguration` has a `configurationOptions` property - a `Map` - that takes dynamic data. This type of information usually comes from a configuration file or environment variables. This information is simply forwarded to every `RequestSink` during their initialization. (See more about configuring an application in [Configuring an Application](configuration.html).)

An example of this behavior is shown in the default `start.dart` script for applications generated by the `aqueduct create` command-line tool:

```dart
var configFileName = "config.yaml";

var config = new WildfireConfiguration(configFileName);

var app = new Application<WildfireSink>();
app.configuration.port = config.port;
app.configuration.configurationOptions = {  
  WildfireSink.ConfigurationKey: config
};

await app.start();
```

Notice the key in `configurationOptions` is a static variable from the `RequestSink` subclass. This convention is useful to avoid stringly-typed data; `RequestSink` subclasses should declare all of the keys for the `Map` they expect to receive in their constructor.

## Subclassing RequestSink

In order for an application to do anything useful, it needs a `RequestSink` subclass. This class has two main responsibilities.

The first responsibility of a `RequestSink` is that it is the first `RequestController` that will receive an HTTP request. For more information on `RequestController`s and how HTTP requests get responded to, see [this guide](request_controller.html).

The other responsibility of a `RequestSink` is to set up routes and initialize resources it will use to fulfill requests. The general flow of initialization goes as follows:

1. Create and initialize resources.
2. Set up routes.
3. (Optional) Perform any asynchronous initialization.
4. Start receiving requests.

A `RequestSink` should declare all of the resources it uses as properties. For example, an object that represents a database connection should be a property of a `RequestSink`. While setting up routes, the `RequestSink` injects its resources to the `RequestController`s it creates.

There are four distinct initialization methods that get invoked during these steps. In order, these methods are the `RequestSink` constructor, `RequestSink.setupRouter`, `RequestSink.willOpen` and `RequestSink.didOpen` and are described in the following sections.

### Create and Initialize Resources (Required)

The constructor of a `RequestSink` will create and initialize resources, the first step of the initialization process.

A `RequestSink` must have an unnamed constructor that takes a `Map<String, dynamic>` that calls its superclasses' constructor with the same argument.

```dart
class WildfireSink extends RequestSink {
  WildfireSink(Map<String, dynamic> options) : super(options) {
    ... set up resources here ...
  }
}
```

The `options` map is always the `configurationOptions` from the `Application<T>` creating the `RequestSink`. An `RequestSink` need not store these options; the values are also available in its `options` property after the constructor completes.

All of the properties of a `RequestSink` should be initialized in its constructor. This allows the next phase of initialization - setting up routes - to inject these resources into the controllers that handle the various routes. For example, a typical `RequestSink` will have some property that holds a database connection; this property should be initialized in the constructor.

A constructor for a `RequestSink` may look like this:

```dart
class WildfireSink extends RequestSink {

  // A constant so the Application<T> can add the right
  // key-value pairs to its configurationOptions.
  static const String ConfigurationKey = "ConfigurationKey";

  // The required constructor
  WildfireSink(Map<String, dynamic> opts) : super(opts) {
    WildfireConfiguration configuration = opts[ConfigurationKey];

    context = contextWithConnectionInfo(configuration.database);

    authServer = new AuthServer<User, Token, AuthCode>(
        new WildfireAuthDelegate());
  }

  ManagedContext context;
  AuthServer authServer;
}
```

A constructor should also set up any application-wide state, such as adding encoders and decoders to `Response` and `HTTPBodyDecoder`.

A constructor should never call asynchronous functions. Some resources require asynchronous initialization - e.g., a database connection has to connect to a database - but those must be fully initialized later. (See a later section on Lazy Resources.)

### Set Up Routes (Required)

Once a `RequestSink` is instantiated, its `setupRouter` method is invoked. This method takes a `Router` that you must configure with all of the routes your application will respond to. (See [Routing](routing.html) for more details.)

When setting up routes, you will create many instances of `RequestController` that will be responsible for processing requests. Any resources these controllers need should be provided in their constructor from the recently initialized properties of the `RequestSink`. For example, `Authorizer`s need an instance of `AuthServer` to validate a request. The following code is an example of this:

```dart
class WildfireSink extends RequestSink {
  WildfireSink(Map<String, dynamic> opts) : super(opts) {  
    authServer = new AuthServer<User, Token, AuthCode>(...);
  }

  AuthServer authServer;

  @override
  void setupRouter(Router router) {
    router
        .route("/path")
        .pipe(new Authorizer(authServer))
        .listen((req) => new Response.ok("Authorized!"));
  }
}
```

You may not call any asynchronous functions in this this method, and by convention, you should not alter the state of any properties.

After `setupRouter` has completed, the `RequestSink.router` property is set to the router this method configured. Routes may not be added to this router after `setupRouter` completes.

### Perform Asynchronous Initialization (Optional)

For any initialization that needs to occur asynchronously, you may override `RequestSink.willOpen`. This method is asynchronous, and the application being started will wait for this method to complete before sending any HTTP requests to the request sink. In general, you should avoid using this method and read the later section on Lazy Resources.

### Start Receiving Requests

Once an `RequestSink` sets up its routes and performs asynchronous initialization, the application will hook up the stream of HTTP requests to the `RequestSink` and data will start flowing. Just prior to this, one last method is invoked on `RequestSink`, `didOpen`. This method is a final callback to the `RequestSink` that indicates all initialization has completed.

## Lazy Resources

An Aqueduct application will probably communicate to other servers and databases. A `RequestSink` will have properties to represent these connections. Resources like these must open a persistent network connection, a process that is asynchronous by nature. Following the initialization process of a `RequestSink`, it may then make sense to create the resources in a constructor and then open them in `willOpen`. And while this could be true, most resources like this should manage the opening and closing of their underlying network connection internally.

For example, an object that has a database connection should open it when it goes to execute a query, but doesn't have a valid connection. This is how `PersistentStore`s work - they store properties that have all of the information they need to connect to a database when initialized, but do not immediately open a connection. The first time the `PersistentStore` has to fulfill a query, it executes a function that opens the database connection. This defers fully loading the resource until it is needed, but there is actually a much more important behavior here.

An Aqueduct application (ideally) will run for a long time. During that time, the servers and databases it connects to may not always be reachable - perhaps they went down to be upgraded or there was an outage of some kind. An Aqueduct application must be able to recover from this. If opening an external connection only happened during startup, an application would not reopen a connection if it went down for some reason. This would be bad.

In the general case, a resource of this nature will have methods that use the underlying connection. These methods must be responsible for ensuring the underlying connection is valid and reopen it (or report failure) if that is not the case. For example, a simple database connection class might implement its `execute` method like so:

```dart
Future execute(String sql) async {
  if (connection == null || !connection.isAvailable) {
    connection = new Connection(...);
    await connection.open();
  }

  return await connection.executeSQL(sql);
}
```

From the perspective of a `RequestController`, it doesn't care about the underlying connection. It invokes `execute`, and the connection object figures out if it needs to establish a connection first:

```dart
@httpGet getThings() async {
  // May or may not create a new connection, but will either return
  // some things or throw an error.
  var things = await connection.execute("select * from things");

  ...
}
```

## Multi-threaded Aqueduct Applications

Aqueduct applications can - and should - be spread across a number of threads. This allows an application to take advantage of multiple CPUs and serve requests faster. In Dart, threads are called *isolates* (and have some slight nuances to them that makes the different than a traditional thread). Spreading requests across isolates is baked into the structure of Aqueduct applications.

When an application is started, it has an optional `numberOfInstances` parameter. An application will spawn `numberOfInstances` isolates and create an instance of `RequestSink` for each. When an HTTP request is received, one of the isolates - and its `RequestSink` - will receive the request while the others will never see it. Each isolate works independently of each other, running as their own "web server" within a web server. Because a `RequestSink` initializes itself in the exact same way on each isolate, each isolate behaves exactly the same way.

An isolate can't share memory with another isolate. Therefore, each `RequestSink` instance has its own set of resources, like database connections. This behavior also makes connection pooling a non-issue - the connections are effectively pooled by the fact that there is a pool of `RequestSink`s. If a `RequestSink` creates a database connection and an application is started with four isolates, there will be four database connections total.

However, there are times where you want your own pool or you want to share a single resource across multiple isolates. For example, an API that must register with some other server (like in a system with an event bus) or must maintain a single persistent connection (like the error pipe to Apple's Push Notification Service or a streaming connection to Nest). These types of resources and registrations should not be created by a `RequestSink`, because they will occur more than once.

This is all still possible in Aqueduct.

The Dart script that starts an Aqueduct application is running on the main isolate. When the application is started, it creates a new isolate and `RequestSink` for each `numberOfInstances` parameter. Therefore, there are N + 1 isolates in the application: the main isolate and each `RequestSink` isolate.

Now, let's say that this application needs a single connection to Nest. The start script should create an isolate that will maintain a connection to Nest. The `SendPort` of the isolate is sent in the `configurationOptions` so that each `RequestSink` has it.

```dart
import 'package:aqueduct/aqueduct.dart';
import 'package:myapp/myapp.dart';

main() {
  var config = new MyAppConfig("config.yaml");

  var nestIsolate = await Isolate.spawn(nestEntryPoint,
    config.nestCredentials)

  var app = new Application<MyAppRequestSink>()
    ..configuration.configurationOptions = {
      MyAppRequestSink.NestPortKey: nestIsolate.sendPort
    };

  app.start();
}
```

When a `RequestSink` is initialized, it will have access to the `SendPort` of the isolate managing the Nest connection. It can then send a message to that isolate and register for callbacks:

```dart
MyAppRequestSink(Map<String, dynamic> opts) : super(opts) {
  var port = opts[NestPortKey];

  var receivePort = new ReceivePort();
  port.send(receivePort.sendPort);
  receivePort.listen(nestHandler);
}
```

The Nest connection isolate will receive the `SendPort` of the `RequestSink` isolate and store it. When an event comes from Nest, the Nest connection isolate will send it to one of its registered `RequestSink` isolates. The `RequestSink` may also keep a reference to the Nest connection's `SendPort` to maintain bidirectional communication.

## Preprocessing Requests and initialHandler

By default, when a `RequestSink` receives an HTTP request, it immediately forwards it to its `router`. However, if an application wishes to insert middleware prior to routing, use another router or forego routing altogether, the `Router` can be skipped. Every `RequestSink` has an `initialHandler` property that it forwards all requests to. This property defaults to the request sink's `router`, but can be overridden to return something else.

If you only wish to preprocess a request, you may instead override `RequestSink.willReceiveRequest`. This asynchronous method takes the incoming `Request` as an argument, but can't respond to it.
